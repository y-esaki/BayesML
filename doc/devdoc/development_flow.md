<img src="../logos/BayesML_logo.png" width="200">

# 典型的な開発フロー Ver.3

<div style="text-align:right">
作成：中原
</div>

ここでは，一つのモデルの実装の流れやポイントを示す．詳細は以下の資料を参照してほしい．

* 実装すべきクラス，メソッドの一覧
  * [abstract_class.md](./abstract_class.md)
* 命名規則
  * [naming_rule.md](./naming_rule.md)
* 例外処理の考え方
  * [exception_rule.md](./exception_rule.md)
* docstringの書き方
  * [docstring_rule.md](./docstring_rule.md)

## 1. モデルの数式による整理

データ生成確率モデル（尤度関数），事前分布，事後分布とそのハイパーパラメータ更新式，予測分布とそのパラメータ計算式を整理する．これは，後の実装の設計図にもなるし，ライブラリの使い方を示すWebサイトにも掲載される．箇条書きで各変数の取り得る値の集合を明記し，別行立て数式で密度関数を書く．

### 例，ベルヌーイ分布

>The stochastic data generative model is as follows:
>
>* $x \in \{ 0, 1\}$: a data point
>* $p \in [0, 1]$: a parameter
>
>$$\text{Bern}(x|p) = p^x (1-p)^{1-x}.$$

## 2. GenModelの実装

1. `__init__`, `set_`, `get_`関数を実装する
   * `__init__`には
     * `c_`で始まる変数のうち，他の変数と関連する値（次元等）についてはデフォルト値を設定せず，入力を必須にする．
     * `c_`で始まる変数を用いてパラメータ，ハイパーパラメータの配列サイズを決める．
     * その後，`set_params`と`set_h_params`を呼ぶ．
   * `set_`関数では入力されたパラメータが正しい集合に属しているか（上記のベルヌーイ分布なら$p \in [0, 1]$を満たすかどうか等）を判定する関数を実装する．
     * 必ず値渡しで変数値を更新し，なおかつ可能な限りin-placeな処理を実現する．
     * `c_`で始まる変数は変更しなくてよく，それに整合しない場合はエラーを返す．
     * 他の変数と独立にその変数が正しいか判定する関数は`bayesml/_check.py`に整理してある．もしそこに見つからない場合は後の人も使えるように`bayesml/_check.py`に追記しておく．ただし，その際は`develop-check`ブランチ上で追記し，中原のチェックを受けてから自分の作業ブランチにマージするようにする．
     * 複数の変数の次元の整合性についてはブロードキャストできるかどうかで判定できる部分はそれに任せる．明示的に次元をそろえたい場合は`bayesml/_check.py`の`shape_consistency`で確認する．使用例は`bayesml/gaussianmixture/_gaussianmixture.py`を参照
     * その他の，複数の変数間の関係によって入力が正しいか否か変わる場合は各モデル上に実装する．
   * `get_`関数は単に辞書を返すだけである．ただし，`set_`の引数と同じ順番で返すようにする．（生成，学習モデル間のパラメータ，ハイパーパラメータの受け渡し効率化のため．また，`save_`，`load_`関数の統一的実装のため）．
   * `save_`, `load_`関数は親クラスのものが統一的に使えるため，オーバーライドする必要はない．
2. `gen_params`, `gen_sample`, `visualize_model`を実装する
   * 先に実装した`set_`関数でハイパーパラメータやパラメータを変化させたときに，生成されるパラメータやサンプルの挙動が妥当かどうかを`visualize_model`でチェックする．

## 3. LearnModelの実装

1. `__init__`, `set_`, `get_`, 関数を実装する
   * `__init__`には
     * `c_`で始まる変数のうち，他の変数と関連する値（次元等）についてはデフォルト値を設定せず，入力を必須にする．
     * `c_`で始まる変数を用いてパラメータ，ハイパーパラメータの配列サイズを決める．
     * その後，`set_h0_params`を呼ぶ．
   * `set_`関数では入力されたパラメータが正しい集合に属しているか（上記のベルヌーイ分布なら$p \in [0, 1]$を満たすかどうか等）を判定する関数を実装する．
     * 必ず値渡しで変数値を更新し，なおかつ可能な限りin-placeな処理を実現する．
     * `c_`で始まる変数は変更しなくてよく，それに整合しない場合はエラーを返す．
     * 他の変数と独立にその変数が正しいか判定する関数は`bayesml/_check.py`に整理してある．もしそこに見つからない場合は後の人も使えるように`bayesml/_check.py`に追記しておく．ただし，その際は`develop-check`ブランチ上で追記し，中原のチェックを受けてから自分の作業ブランチにマージするようにする．
     * 複数の変数の次元の整合性についてはブロードキャストできるかどうかで判定できる部分はそれに任せる．明示的に次元をそろえたい場合は`bayesml/_check.py`の`shape_consistency`で確認する．使用例は`bayesml/gaussianmixture/_gaussianmixture.py`を参照
     * その他の，複数の変数間の関係によって入力が正しいか否か変わる場合は各モデル上に実装する．
   * `set_h0_params`では，`reset_hn_params`を呼ぶ（同じ記述の繰り返しをなるべく避け，途中でバグが見つかっても1箇所修正すれば漏れなく全体が修正されるような構成とする）．
   * `set_hn_params`では，`calc_pred_dist`を呼ぶ（同じ記述の繰り返しをなるべく避け，途中でバグが見つかっても1箇所修正すれば漏れなく全体が修正されるような構成とする）．
   * この時点では`calc_pred_dist`の中身は`pass`でも構わない．
   * `get_`関数は単に辞書を返すだけである．ただし，`set_`の引数と同じ順番で返すようにする．（生成，学習モデル間のパラメータ，ハイパーパラメータの受け渡し効率化のため．また，`save_`，`load_`関数の統一的実装のため）．
   * `save_`, `load_`, `reset_hn_params`, `overwrite_h0_params`関数は親クラスのものが統一的に使えるため，オーバーライドする必要はない．
2. `update_posterior`と`visualize_posterior`を実装する
   * 行列のサイズが合っているかを常に確認する．できるだけ非正方行列でテストする．in-placeな処理を心がける．
   * 変分ベイズ法による近似アルゴリズムの場合は変分下界，更新式の順で実装し，更新式を一つ増やすごとにどんなデータに対しても変分下界が上昇することを確認する．
   * 真のパラメータを固定してGenModelからサンプルを生成，生成されたサンプルから`update_posterior`で事後分布を更新，`visualize_posterior`で可視化し，真のパラメータに事後分布のピークが立つか確認する．
   * いくつかの方法で実装してみて値が一致するかを確認するとバグが見つかることがある
     * 小さい問題で手計算と値が一致するか確認する
     * for文を使った実装とnumpyのブロードキャストを利用した実装を比較する
     * 勾配を利用するアルゴリズムなら，解析的に計算したものと，数値微分を比較する
   * 反復系のアルゴリズムなら一部の変数を真の値に固定して挙動を確認することでバグが見つかることがある．
   * 特殊な問題（混合要素数1の場合など）に対する挙動と比較するとバグが見つかることがある．
   * ある変数を変化させたとき関連して変化するはず（しないはず）の変数の挙動を見ることによってバグが見つかることがある．
3. `estimate_param`を実装する．
   * `visualize_posterior`で分布を表示しながら出力される期待値や最頻値が妥当かどうか確認する．
   * その他のデバッグのノウハウは2. と同様である．
4. `calc_pred_dist`と`make_prediction`を実装する．
   * 真のパラメータを固定してGenModelから生成したサンプルを予測して精度を確認する．
   * その他のデバッグのノウハウは2. と同様である．
